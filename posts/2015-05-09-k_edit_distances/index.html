<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>找出编辑距离不大于 K 的单词 - Gradient Ascent</title><meta name=description content="通过 Trie 提高搜索效率"><meta property="og:title" content="找出编辑距离不大于 K 的单词"><meta property="og:description" content="通过 Trie 提高搜索效率"><meta property="og:type" content="article"><meta property="og:url" content="https://wilbeibi.com/posts/2015-05-09-k_edit_distances/"><meta property="og:site_name" content="Gradient Ascent"><meta property="article:published_time" content="2015-05-09T00:00:00Z"><meta name=twitter:card content="summary"><meta name=twitter:title content="找出编辑距离不大于 K 的单词"><meta name=twitter:description content="通过 Trie 提高搜索效率"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel="shortcut icon" href=/favicon.ico><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&family=Lora:wght@500&family=Ubuntu+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css></head><body><div class=container><div class=header><a href=/>wilbeibi</a>'s Gradient Ascent</div><div class=navigation><ul><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/pages/about/>About</a></li></ul></div><div class=body><h1>找出编辑距离不大于 K 的单词</h1><p class=date>written on May 09, 2015</p><h1 id=关于-edit-distance-的一道题>关于 edit distance 的一道题</h1><p>最近看到一个很有意思的面试题：给一个单词和一个字典，找出字典中所有和给定单词编辑距离不大于 k 的词。</p><p>一个常见的思路是遍历一遍，求单词和字典中每一项的编辑距离。我们知道编辑距离是二维 DP，时间复杂度为 $O(L^2)$，其中 L 为每个单词平均长度，则总时间复杂度为$O(NL^2)$， N 为字典中词的个数。</p><p>这个方法的问题在于，一旦查询单词变多，性能会很糟糕。基于<a href=http://www.zhihu.com/question/29592463>知乎 Lee Shellay的回答</a>，可以通过构造 Trie， 结合 DFS，来解决这个问题。</p><p>所以算法思路并不难：</p><ol><li>根据字典中的单词构造前缀树，标记每个单词结束时的结束符为 ’$’。</li><li>设计函数 API 为<code>check_fuzzy(trie, word, path, tol)</code>。<code>trie</code>是在树中当前走到的节点，<code>word</code> 表示走到当前节点剩余需要处理的查询单词，<code>path</code>表示走到当前节点已经记录的字典单词前缀，<code>tol</code> 表示剩余可容忍的编辑距离。然后定义一个set，不断找到可能的单词并入这个set，直到结束。
所以，函数只在<code>tol</code> 为0时候终止（为什么不是<code>word</code>为空时候终止？因为有可用的编辑距离都用在增加后缀的情况）。</li></ol><ul><li>匹配当前字符，有两种情况：匹配，那么直接递归下一层；不匹配，可能是字母不一致或者是 word 已经结束（这个情况很容易被忽略），需要 tol 减一后递归下一层。</li><li>增加任意字母（字典单词比查询单词多字母）。这里和知乎回答里的不一样，那里是枚举了26个字母，其实只要枚举当前 tree 的所有节点字母就行了（Jayxon 大牛想到的）。</li><li>删除字符。word 向后移一个字母，tol 减一。</li></ul><p>最后代码如下：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#57606a># Based on Lee Shellay&#39;s code http://www.zhihu.com/question/29592463</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END <span style=color:#0550ae>=</span> <span style=color:#0a3069>&#39;$&#39;</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>def</span> <span style=color:#6639ba>make_trie</span><span style=color:#1f2328>(</span>words<span style=color:#1f2328>):</span>
</span></span><span style=display:flex><span>    trie <span style=color:#0550ae>=</span> <span style=color:#1f2328>{}</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>for</span> word <span style=color:#0550ae>in</span> words<span style=color:#1f2328>:</span>
</span></span><span style=display:flex><span>        t <span style=color:#0550ae>=</span> trie
</span></span><span style=display:flex><span>        <span style=color:#cf222e>for</span> c <span style=color:#0550ae>in</span> word<span style=color:#1f2328>:</span>
</span></span><span style=display:flex><span>            <span style=color:#cf222e>if</span> c <span style=color:#0550ae>not</span> <span style=color:#0550ae>in</span> t<span style=color:#1f2328>:</span>
</span></span><span style=display:flex><span>                t<span style=color:#1f2328>[</span>c<span style=color:#1f2328>]</span> <span style=color:#0550ae>=</span> <span style=color:#1f2328>{}</span>
</span></span><span style=display:flex><span>            t <span style=color:#0550ae>=</span> t<span style=color:#1f2328>[</span>c<span style=color:#1f2328>]</span>
</span></span><span style=display:flex><span>        t<span style=color:#1f2328>[</span>END<span style=color:#1f2328>]</span> <span style=color:#0550ae>=</span> <span style=color:#1f2328>{}</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>return</span> trie
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>def</span> <span style=color:#6639ba>check_fuzzy_v4</span><span style=color:#1f2328>(</span>trie<span style=color:#1f2328>,</span> word<span style=color:#1f2328>,</span> path <span style=color:#0550ae>=</span> <span style=color:#0a3069>&#39;&#39;</span><span style=color:#1f2328>,</span> tol <span style=color:#0550ae>=</span> <span style=color:#0550ae>1</span><span style=color:#1f2328>):</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>if</span> tol <span style=color:#0550ae>&lt;</span> <span style=color:#0550ae>0</span><span style=color:#1f2328>:</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>return</span> <span style=color:#6639ba>set</span><span style=color:#1f2328>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ps <span style=color:#0550ae>=</span> <span style=color:#6639ba>set</span><span style=color:#1f2328>()</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>if</span> word <span style=color:#0550ae>==</span> <span style=color:#0a3069>&#39;&#39;</span><span style=color:#1f2328>:</span>
</span></span><span style=display:flex><span>        <span style=color:#cf222e>if</span> END <span style=color:#0550ae>in</span> trie<span style=color:#1f2328>:</span>
</span></span><span style=display:flex><span>             ps <span style=color:#0550ae>=</span> <span style=color:#1f2328>{</span>path<span style=color:#1f2328>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>for</span> k <span style=color:#0550ae>in</span> trie<span style=color:#1f2328>:</span>
</span></span><span style=display:flex><span>        <span style=color:#57606a># match current or mark as substition</span>
</span></span><span style=display:flex><span>        ps <span style=color:#0550ae>|=</span> check_fuzzy_v4<span style=color:#1f2328>(</span>trie<span style=color:#1f2328>[</span>k<span style=color:#1f2328>],</span> word<span style=color:#1f2328>[</span><span style=color:#0550ae>1</span><span style=color:#1f2328>:],</span> path<span style=color:#0550ae>+</span>k<span style=color:#1f2328>,</span> tol <span style=color:#0550ae>-</span> <span style=color:#1f2328>(</span><span style=color:#0550ae>not</span> word <span style=color:#0550ae>or</span> k <span style=color:#0550ae>!=</span> word<span style=color:#1f2328>[</span><span style=color:#0550ae>0</span><span style=color:#1f2328>]))</span>
</span></span><span style=display:flex><span>        <span style=color:#57606a># add random char</span>
</span></span><span style=display:flex><span>        ps <span style=color:#0550ae>|=</span> check_fuzzy_v4<span style=color:#1f2328>(</span>trie<span style=color:#1f2328>[</span>k<span style=color:#1f2328>],</span> word<span style=color:#1f2328>,</span> path<span style=color:#0550ae>+</span>k<span style=color:#1f2328>,</span> tol<span style=color:#0550ae>-</span><span style=color:#0550ae>1</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#57606a># delete one (if word is empty, word[2:] will not report error)</span>
</span></span><span style=display:flex><span>    ps <span style=color:#0550ae>|=</span> check_fuzzy_v4<span style=color:#1f2328>(</span>trie<span style=color:#1f2328>,</span> word<span style=color:#1f2328>[</span><span style=color:#0550ae>1</span><span style=color:#1f2328>:],</span> path<span style=color:#1f2328>,</span> tol<span style=color:#0550ae>-</span><span style=color:#0550ae>1</span><span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>return</span> ps
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#cf222e>if</span> <span style=color:#953800>__name__</span> <span style=color:#0550ae>==</span> <span style=color:#0a3069>&#39;__main__&#39;</span><span style=color:#1f2328>:</span>
</span></span><span style=display:flex><span>    words <span style=color:#0550ae>=</span> <span style=color:#1f2328>[</span><span style=color:#0a3069>&#39;hello&#39;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#39;hela&#39;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#39;hel&#39;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#39;dokm&#39;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#39;i&#39;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#39;ke&#39;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#39;ik&#39;</span><span style=color:#1f2328>]</span>
</span></span><span style=display:flex><span>    t <span style=color:#0550ae>=</span> make_trie<span style=color:#1f2328>(</span>words<span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>    <span style=color:#6639ba>print</span> check_fuzzy_v4<span style=color:#1f2328>(</span>t<span style=color:#1f2328>,</span> <span style=color:#0a3069>&#39;helo&#39;</span><span style=color:#1f2328>,</span><span style=color:#0a3069>&#39;&#39;</span><span style=color:#1f2328>,</span> tol<span style=color:#0550ae>=</span><span style=color:#0550ae>2</span><span style=color:#1f2328>)</span>
</span></span></code></pre></div><p>然后试试大一点的数据。我们知道在<code>/usr/share/dict/words</code>存着拼写检查的单词表，一共 2.4M 共 235886个单词（至少在我的 Mac 上是这么多）。可以用它来构造字典 <code>cat /usr/share/dict/words > ./words.txt</code>。然后把一句话改的乱七八糟，用代码来跑跑试试：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#cf222e>def</span> <span style=color:#6639ba>test</span><span style=color:#1f2328>():</span>
</span></span><span style=display:flex><span>    origin <span style=color:#0550ae>=</span> <span style=color:#0a3069>&#34;For you know only a heap of broken images&#34;</span>
</span></span><span style=display:flex><span>    modified <span style=color:#0550ae>=</span> <span style=color:#0a3069>&#34;Far your knn onlie a deep of borken iimaes&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    words_list <span style=color:#0550ae>=</span> <span style=color:#1f2328>[</span>line<span style=color:#0550ae>.</span>strip<span style=color:#1f2328>()</span> <span style=color:#cf222e>for</span> line <span style=color:#0550ae>in</span> <span style=color:#6639ba>open</span><span style=color:#1f2328>(</span><span style=color:#0a3069>&#39;words.txt&#39;</span><span style=color:#1f2328>,</span> <span style=color:#0a3069>&#39;r&#39;</span><span style=color:#1f2328>)]</span>
</span></span><span style=display:flex><span>    tree <span style=color:#0550ae>=</span> make_trie<span style=color:#1f2328>(</span>words_list<span style=color:#1f2328>)</span>
</span></span><span style=display:flex><span>    <span style=color:#cf222e>for</span> w <span style=color:#0550ae>in</span> modified<span style=color:#0550ae>.</span>split<span style=color:#1f2328>():</span>
</span></span><span style=display:flex><span>        <span style=color:#6639ba>print</span> check_fuzzy_v4<span style=color:#1f2328>(</span>tree<span style=color:#1f2328>,</span> w<span style=color:#1f2328>,</span> tol<span style=color:#0550ae>=</span><span style=color:#0550ae>2</span><span style=color:#1f2328>)</span>
</span></span></code></pre></div><p>结果也挺快的:</p><ul><li>CPython: 2.53s user 0.25s system 50% cpu 5.470 total</li><li>Pypy: 1.63s user 0.19s system 43% cpu 4.186 total</li></ul><p>就是这样, 喵~</p><p>PS: Lee Shellay回答又更新了，提升了性能和准确度，代码比我这的好，欢迎去看。</p></div><div class=footer><p>Design by <a href=https://github.com/mitsuhiko/lucumr>Armin Ronacher</a>.</p><p>Subscribe via <a href=https://wilbeibi.com/index.xml>RSS</a>.</p></div></div></body></html>