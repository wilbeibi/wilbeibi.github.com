<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>How to delete nodes of linked list with pointers-to-pointers (Chinese) - Gradient Ascent</title><meta name=description content="算法题中如何用二级指针简化代码"><meta property="og:title" content="How to delete nodes of linked list with pointers-to-pointers (Chinese)"><meta property="og:description" content="算法题中如何用二级指针简化代码"><meta property="og:type" content="article"><meta property="og:url" content="https://wilbeibi.com/posts/2015-02-12-2d-pointer/"><meta property="og:site_name" content="Gradient Ascent"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2015-02-12T00:00:00Z"><meta property="article:modified_time" content="2026-02-16T16:16:06-08:00"><meta property="article:author" content="wilbeibi"><meta property="article:tag" content="algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to delete nodes of linked list with pointers-to-pointers (Chinese)"><meta name=twitter:description content="算法题中如何用二级指针简化代码"><link rel=icon type=image/svg+xml href=/favicon.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel="shortcut icon" href=/favicon.ico><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&family=JetBrains+Mono:wght@400;700&display=swap" rel=stylesheet><link href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css rel=stylesheet><link rel=canonical href=https://wilbeibi.com/posts/2015-02-12-2d-pointer/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/instantsearch.css@7.4.5/themes/satellite-min.css><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"\"How to delete nodes of linked list with pointers-to-pointers (Chinese)\"","description":"\"算法题中如何用二级指针简化代码\"","datePublished":"2015-02-12T00:00:00Z","dateModified":"2026-02-16T16:16:06-08:00","author":{"@type":"Person","name":"\"wilbeibi\"","url":"https:\/\/wilbeibi.com\/"},"publisher":{"@type":"Person","name":"\"wilbeibi\""},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/wilbeibi.com\/posts\/2015-02-12-2d-pointer\/"},"keywords":"[\"algorithms\"]"}</script></head><body><div class=container><div class=header><a href=/>wilbeibi</a>'s Gradient Ascent</div><div class=navigation><ul><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/pages/about/>About</a></li></ul></div><div class=body><h1>How to delete nodes of linked list with pointers-to-pointers (Chinese)</h1><p class=date>written on February 12, 2015 · 1 min read</p><p>我在用C++写 Leetcode中 Remove duplicates from linked list II 一题时，看到别人的一份代码，感觉写法很有趣，细细研究了一下。受益不少。</p><p>在大部分链表题中，我们习惯于创建一个空节点dummy，使之指向链表的头结点，以方便对
第一个节点进行操作（比如，删除它）。最后答案返回dummy.next。比较有节操的同学会在
删除链表的某些节点时用delete，以免内存泄露，但是难道就没有考虑过dummy节点感受么？</p><p>使用一个二维指针，可以优雅的解决了这个问题。</p><p>举个简单的🌰：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#57606a>/*
</span></span></span><span style=display:flex><span><span style=color:#57606a> * Suppose we have a linked list &#34;1-&gt;2-&gt;3&#34;, we want to delete the    
</span></span></span><span style=display:flex><span><span style=color:#57606a> * second node, remains &#34;1-&gt;3&#34;.
</span></span></span><span style=display:flex><span><span style=color:#57606a> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ListNode <span style=color:#0550ae>**</span>p <span style=color:#0550ae>=</span> <span style=color:#0550ae>&amp;</span>head<span style=color:#1f2328>,</span> <span style=color:#0550ae>*</span>succ<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>p <span style=color:#0550ae>=</span> <span style=color:#0550ae>&amp;</span><span style=color:#1f2328>(</span><span style=color:#0550ae>*</span>p<span style=color:#1f2328>)</span><span style=color:#0550ae>-&gt;</span>next<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>succ <span style=color:#0550ae>=</span> <span style=color:#1f2328>(</span><span style=color:#0550ae>*</span>p<span style=color:#1f2328>)</span><span style=color:#0550ae>-&gt;</span>next<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span><span style=color:#cf222e>delete</span> <span style=color:#1f2328>(</span><span style=color:#0550ae>*</span>p<span style=color:#1f2328>);</span>
</span></span><span style=display:flex><span><span style=color:#1f2328>(</span><span style=color:#0550ae>*</span>p<span style=color:#1f2328>)</span> <span style=color:#0550ae>=</span> succ<span style=color:#1f2328>;</span>
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><p>尝试解释一下下。<code>p</code>是一个二级指针，也就是说，在一开始，<code>p</code>是一个指向一个指向<code>head</code>指针的指针（也就是<code>(*p)</code>指向<code>head</code>）。这样的好处就是，当我们需要在某一个时刻删除指向的节点（<code>delete *p</code>操作），p本身不受影响（当然，是p指向的指针所对应的内存空间被释放了）。唯一一点不方便的时，其他每次移动的时候，都要用<code>(*p)</code>（p淡淡的看着他指向的指针往后移。）</p><p>和用dummy解法不同的是，dummy解法指针后移是<code>ptr = ptr->next;</code>。那我们这呢？<code>(*p) = (*p)->next;</code>？这样是错的。比如<code>1->2</code>里从<code>1</code>移动到<code>2</code>的过程中，就把节点<code>1</code>修改了。所以，要移动的是p。即为<code>p = &(*p)->next</code>，其中<code>-></code>的优先级是高于<code>&</code>的，把p赋值为<code>(*p)-></code>的地址，所以现在<code>(*p)</code>指向老<code>(*p)</code>的next。</p><p>另一个大家可能关心的问题，在<code>delete (*p)</code>后，<code>(*p)</code>的前驱节点的next是怎么不找丢的呀？这其实涉及到<code>delete</code>的本质（Stackoverflow对这个问题有个不错的<a href=http://stackoverflow.com/a/11603084/1035859>回答</a>）。当我们调用<code>delete</code>的时候，那块内存里的数据其实并没有消失，只是这块内存地址被标记为可以利用，当之后的程序需要new的时候，才有可能覆盖掉这里的数据。就像爱情，没有一段新的覆盖，老的怎么忘的掉（情人节了还在改博客，唉~~）。所以这个代码严格意义上说是由风险的，如果在delete的一瞬间，正好另一个程序/进程new了一块内存，又刚好是这里，这个方法就废了。fix的方法就是delete前，赋给一个临时变量，把next覆盖当前，再delete临时变量。</p><p>修改的过程中，发现陈皓也写过<a href=http://coolshell.cn/articles/8990.html>类似的文章</a>，这个trick被Linus举例为什么才是core low-level coding，真正懂指针的做法。 他的文章还有配图，如果我表述的还是没让大家理解，推荐去读一下。</p><p>PS：《Pointers In C》的第十二章《Using Structures and Pointers》，也有关于指针链表操作的详细解释。</p><p><img src=http://ecx.images-amazon.com/images/I/51A8TNWQ3BL.jpg alt></p><div class=post-tags><a href=https://wilbeibi.com/tags/algorithms/>algorithms</a></div></div><div class=footer><p>Design by <a href=https://github.com/mitsuhiko/lucumr>Armin Ronacher</a>.</p><p>Subscribe via <a href=https://wilbeibi.com/index.xml>RSS</a>.</p></div></div></body></html>